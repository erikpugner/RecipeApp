<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Recipe Generator</title>
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font --><style>
        body { font-family: 'Inter', sans-serif; background-color: #f7f7f7; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <!-- Main Application Container --><div id="app-container" class="w-full max-w-xl bg-white shadow-2xl rounded-xl p-8 transition-all duration-300">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-4 text-center">
            Culinary Idea Generator üçΩÔ∏è
        </h1>
        <p class="text-gray-500 mb-6 text-center">
            Need dinner inspiration? Tell us what you're craving, and we'll cook up a fresh recipe idea generated by Gemini.
        </p>

        <!-- Cuisine Input (New Feature) --><div class="mb-6">
            <label for="cuisine-input" class="block text-sm font-medium text-gray-700 mb-2">What cuisine are you in the mood for?</label>
            <input type="text" id="cuisine-input" placeholder="e.g., Italian, Thai, Vegan" 
                   class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm transition duration-150">
        </div>

        <!-- Generate Button --><button id="generate-button"
                class="w-full py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-lg hover:bg-indigo-700 transition duration-150 ease-in-out transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-indigo-300 active:bg-indigo-800">
            Generate New Recipe
        </button>

        <!-- Loading Indicator --><div id="loading-indicator" class="hidden flex justify-center items-center py-6">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span class="text-indigo-600 font-medium">Cooking up an idea...</span>
        </div>

        <!-- Recipe Output Area --><div id="recipe-output" class="mt-8 pt-6 border-t border-gray-200">
            <h2 id="recipe-title" class="text-2xl font-bold text-gray-700 mb-4 hidden"></h2>
            <div id="recipe-content" class="text-gray-600 space-y-4">
                <p class="text-center text-gray-400">Your delicious new recipe will appear here!</p>
            </div>
            <!-- Source Citations Area (only visible if sources are available) --><div id="sources-area" class="mt-6 p-3 bg-gray-50 rounded-lg hidden">
                <h3 class="text-sm font-semibold text-gray-500 mb-2">Sources Used:</h3>
                <ul id="sources-list" class="text-xs text-indigo-600 space-y-1"></ul>
            </div>
        </div>

    </div>

    <script>
        // Use an empty string for the API Key if the user hasn't provided one.
        // The execution environment will handle injection.
        const apiKey = ""; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const generateButton = document.getElementById('generate-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const recipeTitleElement = document.getElementById('recipe-title');
        const recipeContentElement = document.getElementById('recipe-content');
        const sourcesArea = document.getElementById('sources-area');
        const sourcesList = document.getElementById('sources-list');
        const cuisineInput = document.getElementById('cuisine-input'); // New input element

        generateButton.addEventListener('click', generateRecipe);

        /**
         * Converts the markdown response into basic HTML structure for display.
         * Note: This is a simple conversion and does not support full markdown features.
         */
        function formatMarkdownToHtml(markdown) {
            // Remove dollar signs (e.g., "$1 cup" becomes "1 cup")
            let html = markdown.replace(/\$(.*?)\$/g, '$1');
            
            // Replace **bold** with <strong>
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Replace # Heading 1 with <h3>
            html = html.replace(/^#\s(.*?)$/gm, '<h3>$1</h3>');

            // Replace * lists with <ul><li>
            html = html.replace(/^\*\s(.*?)$/gm, '<li>$1</li>');
            html = `<ul>${html}</ul>`; // Wrap list items in ul tag

            // Replace newlines with paragraph breaks, but only outside list structures
            html = html.split('\n').map(line => {
                if (line.startsWith('<h3>') || line.startsWith('<li>') || line.startsWith('<ul>') || line.startsWith('</ul>')) {
                    return line;
                }
                return line.trim() === '' ? '' : `<p>${line.trim()}</p>`;
            }).join('');

            // Clean up multiple ul tags if they appear in succession
            html = html.replace(/<\/ul><ul>/g, '');

            return html;
        }


        /**
         * Main function to call the Gemini API for recipe generation.
         */
        async function generateRecipe() {
            // UI state management
            generateButton.disabled = true;
            loadingIndicator.classList.remove('hidden');
            recipeTitleElement.classList.add('hidden');
            recipeContentElement.innerHTML = '';
            sourcesArea.classList.add('hidden');
            sourcesList.innerHTML = '';

            // Get user input for cuisine
            const cuisine = cuisineInput.value.trim() || "a quick and healthy dinner";
            
            // Construct the dynamic query
            const userQuery = `Give me a detailed recipe idea for **${cuisine}** that serves two people. Include the title, an ingredient list, and easy instructions.`;
            
            const systemPrompt = "You are a friendly and highly creative world-class chef. You specialize in generating clear, concise, and delicious recipes. Always format your output using markdown headings and bullet points for readability. Do not include any introductory or concluding chatter, only the recipe.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                // Enable Google Search for grounding to get fresh recipe ideas
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                config: {
                    temperature: 0.8 // A bit of creativity for new recipes
                }
            };

            const maxRetries = 3;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API call failed with status: ${response.status}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const markdownText = candidate.content.parts[0].text;
                        
                        // 1. Extract the Title (assuming the first line is the title, before a newline)
                        const lines = markdownText.split('\n');
                        const titleLine = lines.find(line => line.startsWith('#'));
                        
                        if (titleLine) {
                            recipeTitleElement.textContent = titleLine.replace(/#/g, '').trim();
                            recipeTitleElement.classList.remove('hidden');
                        } else {
                            recipeTitleElement.textContent = "A Delicious Recipe";
                            recipeTitleElement.classList.remove('hidden');
                        }
                        
                        // 2. Format and display the rest of the content
                        let contentToFormat = markdownText;
                        if(titleLine) {
                             contentToFormat = markdownText.substring(markdownText.indexOf(titleLine) + titleLine.length).trim();
                        }
                        recipeContentElement.innerHTML = formatMarkdownToHtml(contentToFormat);
                        
                        // 3. Extract and display grounding sources (citations)
                        let sources = [];
                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title);
                        }

                        if (sources.length > 0) {
                            sourcesArea.classList.remove('hidden');
                            sources.forEach(source => {
                                const listItem = document.createElement('li');
                                listItem.innerHTML = `<a href="${source.uri}" target="_blank" class="hover:underline">${source.title}</a>`;
                                sourcesList.appendChild(listItem);
                            });
                        }
                        
                        break; // Success, exit retry loop
                    } else {
                        throw new Error("API response was valid but contained no text content.");
                    }
                } catch (error) {
                    console.error("Attempt failed:", error);
                    // Implement exponential backoff
                    if (i < maxRetries - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        // Last attempt failed
                        recipeTitleElement.textContent = "Error Generating Recipe";
                        recipeTitleElement.classList.remove('hidden');
                        recipeContentElement.innerHTML = '<p class="text-red-500">I apologize, but I ran into an issue fetching the recipe. Please try again!</p>';
                    }
                }
            }
            
            // UI state management (finally)
            generateButton.disabled = false;
            loadingIndicator.classList.add('hidden');
        }

    </script>
</body>
</html>